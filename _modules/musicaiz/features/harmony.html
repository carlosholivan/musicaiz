<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>musicaiz.features.harmony &mdash; Musanalysis 0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/design-tabs.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #222222ff" >
            <a href="../../../index.html">
            <img src="../../../_static/logo_square_dark.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Musicaiz Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../loaders.html">Loaders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structure.html">Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../harmony.html">Harmony</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rhythm.html">Rhythm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tokenizers.html">Tokenizers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../evaluation.html">Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../plotters.html">Plotters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../converters.html">Converters</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/2-write_midi.html">Writing a MIDI file from scratch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/3-plot.html">Plotting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../implementations.html">Implementation Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #222222ff" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Musanalysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>musicaiz.features.harmony</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for musicaiz.features.harmony</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>


<span class="kn">from</span> <span class="nn">musicaiz.harmony</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AllChords</span><span class="p">,</span>
    <span class="n">Interval</span><span class="p">,</span>
    <span class="n">IntervalSemitones</span><span class="p">,</span>
    <span class="n">ChordType</span><span class="p">,</span>
    <span class="n">Scales</span><span class="p">,</span>
    <span class="n">Tonality</span><span class="p">,</span>
    <span class="n">DegreesRoman</span><span class="p">,</span>
    <span class="n">ModeConstructors</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">musicaiz.structure</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Note</span><span class="p">,</span>
    <span class="n">NoteClassBase</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">musicaiz.loaders</span> <span class="kn">import</span> <span class="n">Musa</span>


<div class="viewcode-block" id="_extract_note_positions"><a class="viewcode-back" href="../../../generated/musicaiz.features._extract_note_positions.html#musicaiz.features._extract_note_positions">[docs]</a><span class="k">def</span> <span class="nf">_extract_note_positions</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the note positions in the chromatic scale of the notes in a notes sequence.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    notes: List[Note]</span>
<span class="sd">        A list of `musicaiz` :func:`~musicaiz.structure.Note` objects.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    notes_position: List[int]</span>
<span class="sd">        A list of the position in the chromatic scale of each note in the input notes list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">notes_position</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">note</span> <span class="ow">in</span> <span class="n">note_seq</span><span class="p">:</span>
        <span class="n">note_obj</span> <span class="o">=</span> <span class="n">NoteClassBase</span><span class="o">.</span><span class="n">get_note_with_name</span><span class="p">(</span><span class="n">note</span><span class="o">.</span><span class="n">note_name</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">note_obj</span><span class="o">.</span><span class="n">chromatic_scale_index</span>
        <span class="n">notes_position</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">notes_position</span></div>


<div class="viewcode-block" id="_order_note_seq_by_chromatic_idx"><a class="viewcode-back" href="../../../generated/musicaiz.features._order_note_seq_by_chromatic_idx.html#musicaiz.features._order_note_seq_by_chromatic_idx">[docs]</a><span class="k">def</span> <span class="nf">_order_note_seq_by_chromatic_idx</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts a note seq (list of note objects) by the index of the notes</span>
<span class="sd">    in the chromatic scale.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    notes: List[Note]</span>
<span class="sd">        A list of `musicaiz` :func:`~musicaiz.structure.Note` objects.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    sorted_note_seq: List[int]</span>
<span class="sd">        Sorts the positions of the notes in the chromatic scale.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract the notes indexes in the natural scale</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">_extract_note_positions</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="c1"># Sorts the list of indexes</span>
    <span class="n">sorted_positions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
    <span class="c1"># Sorts the note seq list</span>
    <span class="n">sorted_note_seq</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_positions</span><span class="p">):</span>
        <span class="n">note_seq_pos</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">sorted_note_seq</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">note_seq</span><span class="p">[</span><span class="n">note_seq_pos</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sorted_note_seq</span></div>


<div class="viewcode-block" id="get_chord_type_from_note_seq"><a class="viewcode-back" href="../../../generated/musicaiz.features.get_chord_type_from_note_seq.html#musicaiz.features.get_chord_type_from_note_seq">[docs]</a><span class="k">def</span> <span class="nf">get_chord_type_from_note_seq</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the chord type :func:`~musicaiz.harmony.ChordType` of a list of</span>
<span class="sd">    `musicaiz` :func:`~musicaiz.structure.Note` objects.</span>

<span class="sd">    The chord type is equal to the number of note names or different notes positions</span>
<span class="sd">    in the chromatic scale that are different in the note seq.</span>
<span class="sd">    This functions return the minimum chord type of a note seq.</span>
<span class="sd">    3 different note names are a triad, 4 notes a 7th or 9th (7th the minimum),</span>
<span class="sd">    5 notes a 9th with the 7th and so on.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    notes: List[Note]</span>
<span class="sd">        A list of `musicaiz` :func:`~musicaiz.structure.Note` objects.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    chord_type: str</span>
<span class="sd">        The type of the chord :func:`~musicaiz.harmony.ChordType`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">notes_positions</span> <span class="o">=</span> <span class="n">_extract_note_positions</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="c1"># count the number of different elements in the notes_positions list</span>
    <span class="n">min_type</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">notes_positions</span><span class="p">))</span>
    <span class="n">chord_type</span> <span class="o">=</span> <span class="n">ChordType</span><span class="o">.</span><span class="n">get_type_from_value</span><span class="p">(</span><span class="n">min_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chord_type</span></div>


<div class="viewcode-block" id="get_intervals_note_seq"><a class="viewcode-back" href="../../../generated/musicaiz.features.get_intervals_note_seq.html#musicaiz.features.get_intervals_note_seq">[docs]</a><span class="k">def</span> <span class="nf">get_intervals_note_seq</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">IntervalSemitones</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the intervals between pairs of notes (1st note and the rest of</span>
<span class="sd">    the notes in the note seq) of a sorted note seq.</span>
<span class="sd">    This computes all the intervals between 2 notes, taking into account the</span>
<span class="sd">    notes enharmonics.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    notes: List[Note]</span>
<span class="sd">        A list of `musicaiz` :func:`~musicaiz.structure.Note` objects.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)):</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">get_possible_intervals</span><span class="p">(</span><span class="n">note_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">note_seq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intervals</span></div>


<div class="viewcode-block" id="predict_chords"><a class="viewcode-back" href="../../../generated/musicaiz.features.predict_chords.html#musicaiz.features.predict_chords">[docs]</a><span class="k">def</span> <span class="nf">predict_chords</span><span class="p">(</span>
    <span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">NoteClassBase</span><span class="p">,</span> <span class="n">AllChords</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Predicts a chord in a note sequence with only note values,</span>
<span class="sd">    so no note durations atr taken into account.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    notes: List[Note]</span>
<span class="sd">        A list of `musicaiz` :func:`~musicaiz.structure.Note` objects.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check note seq length</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="c1"># Remove duplicated notes in the note seq (12 and 24 are C, we delete 24)</span>
    <span class="n">note_seq</span> <span class="o">=</span> <span class="n">_delete_repeated_note_names</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="c1"># TODO: Compute note seq with enharmonics</span>
    <span class="c1"># We generate all possible note seq permutations bc we don&#39;t know what</span>
    <span class="c1"># is the root note of the chord nor the inversion of the chord</span>
    <span class="n">all_note_seqs</span> <span class="o">=</span> <span class="n">_all_note_seq_permutations</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="n">predicted_chords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">single_note_seq</span> <span class="ow">in</span> <span class="n">all_note_seqs</span><span class="p">:</span>
        <span class="c1"># 1. Measure intervals between pairs of notes</span>
        <span class="c1"># intervals vary if we take enharmonic notes(C - Eb is not equal to C - D#)</span>
        <span class="c1"># intervals is a list of lists of intervals between the enharmonics pairs of notes</span>
        <span class="c1"># so we need to map this to all the possible combinations of intervals</span>
        <span class="n">all_intervals_tuples</span> <span class="o">=</span> <span class="n">get_intervals_note_seq</span><span class="p">(</span><span class="n">single_note_seq</span><span class="p">)</span>
        <span class="n">all_possible_tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">all_intervals_tuples</span><span class="p">))</span>
        <span class="c1"># Remove tuple of (notes, intervals) to only have intervals as items</span>
        <span class="c1"># TODO: Refactor this in other method</span>
        <span class="n">all_intervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a_tuple</span> <span class="ow">in</span> <span class="n">all_possible_tuples</span><span class="p">:</span>
            <span class="n">all_intervals</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">a_tuple</span><span class="p">])</span>
        <span class="c1"># 2. Look into all the possible with a type equal or higher than the note seq type</span>
        <span class="k">for</span> <span class="n">intervals</span> <span class="ow">in</span> <span class="n">all_intervals</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">chord</span> <span class="ow">in</span> <span class="n">AllChords</span><span class="p">:</span>
                <span class="c1"># Now check if the list of intervals corresponds to a chord</span>
                <span class="c1"># We might have intervals that are not in the defined chords due to passing notes</span>
                <span class="c1"># so we check if the chord intervals set is a subset of the predicted intervals</span>
                <span class="n">note</span> <span class="o">=</span> <span class="n">NoteClassBase</span><span class="o">.</span><span class="n">get_note_with_name</span><span class="p">(</span><span class="n">single_note_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">note_name</span><span class="p">)</span>
                <span class="n">chord_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="n">chord</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chord</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="n">chord_tuple</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">predicted_chords</span><span class="p">:</span>
                    <span class="n">predicted_chords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chord_tuple</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_chords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No chord has been matched.&quot;</span><span class="p">)</span>
    <span class="c1"># We store in predicted_chord all the chords that are subsets of out list of predicted</span>
    <span class="c1"># intervals but the last chord in the list will be the more complex chord detected in</span>
    <span class="c1"># (triads will be save 1st, then 7ths, then 9ths...if they match the predicted intervals)</span>
    <span class="c1"># TODO: Return also the inversion</span>
    <span class="c1"># TODO: What if the chord has no all its notes?</span>
    <span class="c1"># If 2 chords have the same root note remove the one with less complexity (if triad and 7th are found, remove triad)</span>
    <span class="c1"># This is bc triads are subsets of 7th which are subsets of 9ths...and we&#39;ve stored them all</span>
    <span class="n">chords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">predicted_chords</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">predicted_chords</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pred1</span> <span class="ow">in</span> <span class="n">predicted_chords</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">pred</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">pred1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>  <span class="c1"># root notes are the same</span>
                <span class="k">if</span> <span class="n">pred</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">chord_type</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">pred1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">chord_type</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">chords</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="c1"># Now give also the enharmonic chords to the obtained chords</span>
    <span class="c1"># Ex.: C major is the same as B# major if we look at note&#39;s pitches</span>
    <span class="c1"># TODO: Refactor this in other method</span>
    <span class="n">all_chords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">chords</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chords</span><span class="p">:</span>
        <span class="n">root_note</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">degree_root</span> <span class="o">=</span> <span class="n">root_note</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contracted</span> <span class="o">+</span> <span class="s2">&quot;1&quot;</span>
        <span class="n">note_obj</span> <span class="o">=</span> <span class="n">Interval</span><span class="o">.</span><span class="n">_initialize_note</span><span class="p">(</span><span class="n">degree_root</span><span class="p">)</span>
        <span class="n">enharmonic_root_note</span> <span class="o">=</span> <span class="n">note_obj</span><span class="o">.</span><span class="n">enharmonic</span>
        <span class="c1"># Some notes (D...) have no enharmonics (only considering notes with 1 accidental)</span>
        <span class="k">if</span> <span class="n">enharmonic_root_note</span> <span class="o">!=</span> <span class="n">root_note</span><span class="p">:</span>
            <span class="n">all_chords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">enharmonic_root_note</span><span class="p">,</span> <span class="n">ch</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">all_chords</span></div>


<div class="viewcode-block" id="predict_scales_degrees"><a class="viewcode-back" href="../../../generated/musicaiz.features.predict_scales_degrees.html#musicaiz.features.predict_scales_degrees">[docs]</a><span class="k">def</span> <span class="nf">predict_scales_degrees</span><span class="p">(</span>
    <span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">DegreesRoman</span><span class="p">,</span> <span class="n">Tonality</span><span class="p">,</span> <span class="n">ModeConstructors</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;This method is similar to `Scales.get_scales_degrees_from_chord`</span>
<span class="sd">    method but in this case applied to an input note_seq, not to a chord.</span>
<span class="sd">    So what we do here is applying chord detection to the note_Seq and then</span>
<span class="sd">    the sacle and degrees mapping for every detected chord in the note_seq.&quot;&quot;&quot;</span>
    <span class="n">possible_chords</span> <span class="o">=</span> <span class="n">predict_chords</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="n">all_scales_degrees</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chord</span> <span class="ow">in</span> <span class="n">possible_chords</span><span class="p">:</span>
        <span class="n">scales_degrees</span> <span class="o">=</span> <span class="n">Tonality</span><span class="o">.</span><span class="n">get_scales_degrees_from_chord</span><span class="p">(</span><span class="n">chord</span><span class="p">)</span>
        <span class="n">all_scales_degrees</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">scales_degrees</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_scales_degrees</span></div>


<div class="viewcode-block" id="predict_possible_progressions"><a class="viewcode-back" href="../../../generated/musicaiz.features.predict_possible_progressions.html#musicaiz.features.predict_possible_progressions">[docs]</a><span class="k">def</span> <span class="nf">predict_possible_progressions</span><span class="p">(</span>
    <span class="n">possible_chords</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">NoteClassBase</span><span class="p">,</span> <span class="n">AllChords</span><span class="p">,</span> <span class="n">ModeConstructors</span><span class="p">]]],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Scales</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DegreesRoman</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all possible scales and degrees from a chords list (chord progression)</span>
<span class="sd">    We retrieve a list of degrees which items correspond to one time step each.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    possible_chords: list</span>
<span class="sd">        the possible chords in each time step. This argument is a list, in which</span>
<span class="sd">        each element is a time step with is another list of the possible degrees that</span>
<span class="sd">        can belong to the same time step. The chords are represented by a tuple of</span>
<span class="sd">        (`degree`, `tonality` and `mode`).</span>

<span class="sd">    scale: str or Scale object.</span>
<span class="sd">        if we do know the scale, the funcion will return only the dict with the key of</span>
<span class="sd">        the input scale and the degrees that belong to that scale. Otherwise we&#39;ll predict</span>
<span class="sd">        all the possible scales and map each chord to its possible scales.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Go through all the chords in each time step or subdivision</span>
    <span class="c1"># Create dict with keys equal to all existing scales in the preogression</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">chords_step</span> <span class="ow">in</span> <span class="n">possible_chords</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chords_step</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">chords</span> <span class="ow">in</span> <span class="n">chords_step</span><span class="p">:</span>
                <span class="n">scale_name</span> <span class="o">=</span> <span class="n">chords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">scale_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scales</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">new_scale</span> <span class="o">=</span> <span class="p">{</span><span class="n">scale_name</span><span class="p">:</span> <span class="p">[]}</span>
                    <span class="n">scales</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">scales</span><span class="p">,</span> <span class="o">**</span><span class="n">new_scale</span><span class="p">}</span>

    <span class="c1"># Fill the degrees list for every scales with the degree value in each time step</span>
    <span class="k">for</span> <span class="n">chords_step</span> <span class="ow">in</span> <span class="n">possible_chords</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chords_step</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scales_time_step</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">step_degrees_scales</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chords</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chords_step</span><span class="p">):</span>
                <span class="n">degree_name</span> <span class="o">=</span> <span class="n">chords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">scale_name</span> <span class="o">=</span> <span class="n">chords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                <span class="n">scales_time_step</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale_name</span><span class="p">)</span>
                <span class="c1"># if degree of a certain scale has been already written in a time step,</span>
                <span class="c1"># we don&#39;t append it to not have duplicates</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">degree_name</span><span class="p">,</span> <span class="n">scale_name</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">step_degrees_scales</span><span class="p">):</span>
                    <span class="n">scales</span><span class="p">[</span><span class="n">scale_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">degree_name</span><span class="p">)</span>
                <span class="n">step_degrees_scales</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">degree_name</span><span class="p">,</span> <span class="n">scale_name</span><span class="p">))</span>
            <span class="n">scales_not_in_step</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">scales</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">scales_time_step</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">scales_not_in_step</span><span class="p">:</span>
                <span class="n">scales</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">scales</span><span class="p">[</span><span class="n">scale</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scales</span></div>


<div class="viewcode-block" id="predict_progression"><a class="viewcode-back" href="../../../generated/musicaiz.features.predict_progression.html#musicaiz.features.predict_progression">[docs]</a><span class="k">def</span> <span class="nf">predict_progression</span><span class="p">(</span>
    <span class="n">scales</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DegreesRoman</span><span class="p">]],</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Scales</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DegreesRoman</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Uses `predict_possible_progressions` to predict all the scales and progressions</span>
<span class="sd">    that belong to a note_seq but this method only returns one of them.</span>
<span class="sd">    If the scale is  known, it returns the progression of that scale, otherwise</span>
<span class="sd">    this method will return the scale that has more known degrees in the progression.</span>
<span class="sd">    Ex.: If a scale has only one known degree in all the time steps, it is probable that</span>
<span class="sd">    the scale is not the correct one (although it is a secundary dominant. If the scale</span>
<span class="sd">    has a predicted degree more time steps the probability of that scale being the</span>
<span class="sd">    correct one increases.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">scale</span><span class="p">,</span> <span class="n">scales</span><span class="p">[</span><span class="n">scale</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_name</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">name</span>
            <span class="k">return</span> <span class="n">scale_name</span><span class="p">,</span> <span class="n">scales</span><span class="p">[</span><span class="n">scale_name</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># TODO: Return scale with less None values</span>
        <span class="k">return</span> <span class="n">scales</span><span class="p">[</span><span class="n">scale</span><span class="p">]</span></div>


<div class="viewcode-block" id="_all_note_seq_permutations"><a class="viewcode-back" href="../../../generated/musicaiz.features._all_note_seq_permutations.html#musicaiz.features._all_note_seq_permutations">[docs]</a><span class="k">def</span> <span class="nf">_all_note_seq_permutations</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Returns a list of lists of all possible orders for a note seq.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)]</span></div>


<div class="viewcode-block" id="_delete_repeated_note_names"><a class="viewcode-back" href="../../../generated/musicaiz.features._delete_repeated_note_names.html#musicaiz.features._delete_repeated_note_names">[docs]</a><span class="k">def</span> <span class="nf">_delete_repeated_note_names</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Removes a repeated note in a note_seq.</span>
<span class="sd">    A repeated note is a note which name (`C`) not pitch is equal to other note name.&quot;&quot;&quot;</span>
    <span class="n">note_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_note_seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">note</span> <span class="ow">in</span> <span class="n">note_seq</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">note</span><span class="o">.</span><span class="n">note_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">note_names</span><span class="p">:</span>
            <span class="n">new_note_seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">note</span><span class="p">)</span>
        <span class="n">note_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">note</span><span class="o">.</span><span class="n">note_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_note_seq</span></div>


<div class="viewcode-block" id="get_harmonic_density"><a class="viewcode-back" href="../../../generated/musicaiz.features.get_harmonic_density.html#musicaiz.features.get_harmonic_density">[docs]</a><span class="k">def</span> <span class="nf">get_harmonic_density</span><span class="p">(</span><span class="n">note_seq</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Note</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes the maximum number of notes that are overlapped in the</span>
<span class="sd">    harmonic axis.&quot;&quot;&quot;</span>
    <span class="c1"># No notes in the sequence means that density is 0.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="c1"># Go tick per tick</span>
    <span class="n">latest_note</span> <span class="o">=</span> <span class="n">Musa</span><span class="o">.</span><span class="n">_last_note</span><span class="p">(</span><span class="n">note_seq</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">step_ticks</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># We&#39;ll compute by steps of 10 ticks which is a low value</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">latest_note</span><span class="o">.</span><span class="n">end_ticks</span><span class="p">,</span> <span class="n">step_ticks</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">note_idx</span><span class="p">,</span> <span class="n">note</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">note_seq</span><span class="p">):</span>
            <span class="c1"># if note ends aftre the next step start, count it</span>
            <span class="k">if</span> <span class="n">note</span><span class="o">.</span><span class="n">start_ticks</span> <span class="o">&lt;</span> <span class="n">step_ticks</span> <span class="o">*</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">note</span><span class="o">.</span><span class="n">end_ticks</span> <span class="o">&gt;=</span> <span class="n">step_ticks</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Carlos Hernandez-Olivan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>